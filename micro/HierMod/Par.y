-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module HierMod.Par
  ( happyError
  , myLexer
  , pProgram
  , pDecl
  , pDecls
  , pImportDirective
  , pQName
  ) where

import Prelude

import qualified HierMod.Abs
import HierMod.Lex
import qualified Data.Text

}

%name pProgram Program
%name pDecl Decl
%name pDecls Decls
%name pImportDirective ImportDirective
%name pQName QName
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('       { PT _ (TS _ 1)    }
  ')'       { PT _ (TS _ 2)    }
  '.'       { PT _ (TS _ 3)    }
  ';'       { PT _ (TS _ 4)    }
  'module'  { PT _ (TS _ 5)    }
  'open'    { PT _ (TS _ 6)    }
  'private' { PT _ (TS _ 7)    }
  'public'  { PT _ (TS _ 8)    }
  'using'   { PT _ (TS _ 9)    }
  'where'   { PT _ (TS _ 10)   }
  '{'       { PT _ (TS _ 11)   }
  '}'       { PT _ (TS _ 12)   }
  L_Name    { PT _ (T_Name $$) }

%%

Name :: { HierMod.Abs.Name }
Name  : L_Name { HierMod.Abs.Name $1 }

Program :: { HierMod.Abs.Program }
Program
  : 'module' Name 'where' '{' Decls '}' { HierMod.Abs.Prg $2 $5 }

Decl :: { HierMod.Abs.Decl }
Decl
  : 'module' Name 'where' '{' Decls '}' { HierMod.Abs.Modl $2 $5 }
  | 'open' QName ImportDirective { HierMod.Abs.Opn $2 $3 }
  | 'private' '{' Decls '}' { HierMod.Abs.Priv $3 }

Decls :: { HierMod.Abs.Decls }
Decls
  : {- empty -} { HierMod.Abs.DNil }
  | Decls ';' Decl { HierMod.Abs.DSnoc $1 $3 }
  | Decl { HierMod.Abs.dSg $1 }

ImportDirective :: { HierMod.Abs.ImportDirective }
ImportDirective
  : {- empty -} { HierMod.Abs.ImportPrivate }
  | 'public' { HierMod.Abs.ImportPublic }
  | 'using' '(' ')' { HierMod.Abs.ImportNothing }

QName :: { HierMod.Abs.QName }
QName
  : Name { HierMod.Abs.QName $1 }
  | Name '.' QName { HierMod.Abs.Qual $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: Data.Text.Text -> [Token]
myLexer = tokens

}

