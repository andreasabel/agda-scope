-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module HierMod.Par
  ( happyError
  , myLexer
  , pProgram
  , pDecl
  , pListDecl
  , pListName
  ) where

import Prelude

import qualified HierMod.Abs
import HierMod.Lex

}

%name pProgram Program
%name pDecl Decl
%name pListDecl ListDecl
%name pListName ListName
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '.'       { PT _ (TS _ 1)    }
  ';'       { PT _ (TS _ 2)    }
  'module'  { PT _ (TS _ 3)    }
  'open'    { PT _ (TS _ 4)    }
  'private' { PT _ (TS _ 5)    }
  'public'  { PT _ (TS _ 6)    }
  'where'   { PT _ (TS _ 7)    }
  '{'       { PT _ (TS _ 8)    }
  '}'       { PT _ (TS _ 9)    }
  L_Name    { PT _ (T_Name $$) }

%%

Name :: { HierMod.Abs.Name }
Name  : L_Name { HierMod.Abs.Name $1 }

Program :: { HierMod.Abs.Program }
Program
  : 'module' Name 'where' '{' ListDecl '}' { HierMod.Abs.Prg $2 $5 }

Decl :: { HierMod.Abs.Decl }
Decl
  : 'module' Name 'where' '{' ListDecl '}' { HierMod.Abs.Modl $2 $5 }
  | 'private' 'module' Name 'where' '{' ListDecl '}' { HierMod.Abs.PrivateModl $3 $6 }
  | 'open' ListName { HierMod.Abs.Open $2 }
  | 'open' ListName 'public' { HierMod.Abs.OpenPublic $2 }

ListDecl :: { [HierMod.Abs.Decl] }
ListDecl
  : {- empty -} { [] }
  | Decl { (:[]) $1 }
  | Decl ';' ListDecl { (:) $1 $3 }

ListName :: { [HierMod.Abs.Name] }
ListName : Name { (:[]) $1 } | Name '.' ListName { (:) $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

